<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <script src="./nikUtils.js"></script> -->
</head>
<style>
    body{
        margin: 0px;
        background-color: rgb(0, 95, 0);
    }
    *{
        box-sizing: border-box;
    }
    .card{
        --card_scale: 1;
        width: calc(128px * var(--card_scale));
        height: calc(178px * var(--card_scale));
        background-color: white;
        border-radius: calc(var(--card_scale) * 10px);
        padding: calc(var(--card_scale) * 10px);
        position: absolute;
    }
    .cardPattern{
        --color1: rgb(255, 255, 255);
        --color2: rgb(255, 100, 100);
        --color3: rgb(210, 173, 255);
        --scale: calc(var(--card_scale) * 0.1);       
        position: relative; 
        width: calc(100% + calc(var(--card_scale) * 10px));
        height: calc(100% + calc(var(--card_scale) * 10px));
        top: calc(var(--card_scale) * -5px);
        left: calc(var(--card_scale) * -5px);
        border-radius: calc(var(--card_scale) * 5px);

        background-image:  linear-gradient(30deg, var(--color2) 12%, transparent 12.5%, transparent 87%, var(--color2) 87.5%, var(--color2)), 
        linear-gradient(150deg, var(--color2) 12%, transparent 12.5%, transparent 87%, var(--color2) 87.5%, var(--color2)), 
        linear-gradient(30deg, var(--color2) 12%, transparent 12.5%, transparent 87%, var(--color2) 87.5%, var(--color2)), 
        linear-gradient(150deg, var(--color2) 12%, transparent 12.5%, transparent 87%, var(--color2) 87.5%, var(--color2)), 
        linear-gradient(60deg, var(--color3) 25%, transparent 25.5%, transparent 75%, var(--color3) 75%, var(--color3)), 
        linear-gradient(60deg, var(--color3) 25%, transparent 25.5%, transparent 75%, var(--color3) 75%, var(--color3));
        background-size: calc(200px * var(--scale)) calc(350px * var(--scale));
        background-position: 0 0, 0 0, 
        calc(100px * var(--scale)) calc(175px * var(--scale)), 
        calc(100px * var(--scale)) calc(175px * var(--scale)), 0 0, 
        calc(100px * var(--scale)) calc(175px * var(--scale));
        background-color: #ffffff;
    }
    #playerhand, #dealerhand, #discard{
        width: inherit;
        height: calc(178px * var(--card_scale));
        /* display: flex;
        gap: 10px; */
        border: 1px solid white;
        border-radius: 10px;
    }
    #activeHands{
        width: 100%;
        display: flex;
        justify-content: space-around;
    }
    .cell{
        width: 100%;
        /* border: 2px solid black; */
        position: absolute;
        /* box-sizing: border-box; */
    }
</style>
<body>
    <button id="playerhitButton">HIT</button>
    <button id="playerstayButton">STAY</button>
    <button id="betButton">BET</button>
    <input id="betInput" value="100" type="number" placeholder="BET">
    <div id="playerBalance"></div>
    <div style="display: flex; justify-content: space-around;">
        <div id="playerScore"></div>        
        <div id="dealerScore"></div>
    </div>
    <div id="cardCountingCount"></div>
    <div id="activeHands"></div>
<script type="module">
    import {removeAll, runFunctionXTimes} from "./nikUtils.js"

    class Container {
        constructor(id = "defaultCont", width = 500, height = 500) {
            this.id = id;
            this.width = width;
            this.height = height;
            this.cards = {};
            this.cellArray = [];
            this.cellWidth = 0;
            this.cellHeight = 0;
            this.padding = 10;
            this.contX = null;
            this.contY = null;

            this.element = this.createCont();
            this.updateContPos = this.updateContPos.bind(this);
            window.addEventListener("resize", this.updateContPos);
            this.updateContPos()
        }

        updateContPos(){
            this.contX = this.element.offsetLeft;
            this.contY = this.element.offsetTop;  
                      
            this.updateCells()
        }

        createCell(){
            const cellElement = document.createElement('div');
            cellElement.classList.add("cell");
            this.element.append(cellElement);
            this.cellArray.push(cellElement);
            this.updateCells();

            // cell.addEventListener
            return cellElement
        }

        removeCells(){
            this.cellArray = [];
            while(this.element.firstChild){this.element.removeChild(this.element.firstChild)};
            this.updateCells();
        }

        updateCells(){
            this.cellArray.forEach((e, i) => {
                this.positionCell(e, i);
                this.setCellDimensions(e);
            });
            this.updateCardPositions()
        }

        createCont(){           
            const element = document.createElement('div');
            element.id = this.id;
            element.style.width = `${this.width}px`;
            element.style.height = `${this.height}px`;
            this.element = element;
            return element
        }

        addCard(card, flipped) {          
            if (!this.cards[card.cardId]) {
                this.cards[card.cardId] = card;
                card.requestElement({flipped})
                if(this.element !== null && card.element !== null){
                    this.createCell().append(card.element)
                }
                this.updateCardPositions();
            } else {
                console.warn(`Card with ID ${card.id} is already in the container.`);
            }
        }

        removeCard(card) {
            if (this.cards[card.cardId]) {
                delete this.cards[card.cardId];
                this.updateCardPositions();
            } else {
                console.warn(`Card with ID ${card.cardId} not found in the container.`);
            }
        }

        clearCards() {
            this.cards = {};
            this.removeCells();
            this.updateCardPositions();
        }

        listCards() {
            return Object.values(this.cards);
        }

        updateCardPositions() {            
            const cardArray = this.listCards();
            const count = cardArray.length;
            if (count === 0) return;
            this.positionCards(cardArray);
        }

        setCellDimensions(cellElement) {
            throw new Error("setCellDimensions() must be implemented by subclasses");
        }

        positionCell(cellElement, index) {
            throw new Error("positionCell() must be implemented by subclasses");
        }

        positionCards(cardArray) {
            throw new Error("positionCards() must be implemented by subclasses");
        }
    }

    class HorizontalContainer extends Container {
        setCellDimensions(cellElement) { 
                       
            cellElement.style.height = `${this.height}px`;
            this.cellWidth = (this.width - this.padding * 2) / this.cellArray.length       
            
            cellElement.style.width = `${this.cellWidth}px`
        }

        positionCell(cellElement, index) {
            const posX = this.contX + this.padding + (this.cellWidth * index)           
            cellElement.style.left = `${posX}px`;
            cellElement.style.top = `${this.contY}px`;
        }

        positionCards(cardArray) {
            cardArray.forEach((card, index) => {                     
                const posX = (this.cellWidth / 2) - (128 / 2);
                const posY = (this.height / 2) - (178 / 2);                               
                card.element.style.left = `${posX}px`;
                card.element.style.top = `${posY}px`;               
            });
        }
    }

    class VerticalContainer extends Container {
        setCellDimensions(cellElement) {
            cellElement.style.width = "100%";
        }

        positionCell(cellElement, index) {
            const height = (this.height - (2 * this.padding)) / this.cellArray.length;
            cellElement.style.height = `${height}px`;
            cellElement.style.top = `${this.padding + (height * index)}px`;
            this.cellHeight = height;
        }

        positionCards(cardArray) {
            
            cardArray.forEach((card, index) => {
                this.contX = this.element.getBoundingClientRect().left; 
                this.contY = this.element.getBoundingClientRect().top;              

                const posX = this.contX + (this.width / 2) - (128 / 2);
                const posY = this.contY + this.padding + (this.cellHeight * index) + (this.cellHeight / 2) - (178 / 2);
                card.element.style.left = `${posX}px`;
                card.element.style.top = `${posY}px`;
            });
        }
    }

    class Card {
        constructor(cardId, suit, rank, value){
            this.cardId = cardId;
            this.suit = suit;
            this.rank = rank;
            this.value = value;
            this.HiLo = null;
            this.element = null;

            if(value <= 6){this.HiLo = -1;} 
            else if (value <= 9){this.HiLo = 0;} 
            else {this.HiLo = 1;}
            const icons = {
                hearts: "♥",
                spades: "♠",
                diamonds: "♦",
                clubs: "♣"
            };
            this.icon = icons[suit];
            this.element = null;
        }

        renderCard(options){           
            const {flipped = false,} = options;
            const cardBack = document.createElement('div');
            cardBack.classList.add("card");
            if(!flipped){
                const rankElement = document.createElement('div');
                rankElement.textContent = this.rank;
                const suitElement = document.createElement('div');
                suitElement.textContent = this.icon;
                if (this.suit === "hearts" || this.suit === "diamonds"){
                    rankElement.style.color = "red";
                    suitElement.style.color = "red";
                }
                cardBack.append(rankElement);
                cardBack.append(suitElement);
            } else {
                const cardPattern = document.createElement('div');
                cardPattern.classList.add('cardPattern');
                cardBack.append(cardPattern);
            }
            return cardBack
        }

        requestElement(options){
            const {flipped = false,} = options;
            this.element = this.renderCard(options);
            return this.element;
        }
    }

    const activeHandsElement = document.getElementById("activeHands");
    const playerHandCont = new HorizontalContainer("playerhand", 500, 200,);
    activeHandsElement.append(playerHandCont.element);
    const playerScoreElement = document.getElementById('playerScore');
    const dealerScoreElement = document.getElementById('dealerScore');
    const dealerHandCont = new HorizontalContainer("dealerhand", 500, 200,);
    activeHandsElement.append(dealerHandCont.element);
    const discardCont = new HorizontalContainer("discard", 500, 200,);
    document.body.append(discardCont.element);

    const playerBalanceElement = document.getElementById('playerBalance');
    const betInput = document.getElementById('betInput');
    
    const playerhitButton = document.getElementById('playerhitButton');
    const playerstayButton = document.getElementById('playerstayButton');
    const betButton = document.getElementById('betButton');

    const cardCountingCount = document.getElementById('cardCountingCount');

    let gameRunning = false;
    let playerBalance = 1000;
    playerBalanceElement.textContent = playerBalance;
    let betAmount = 0;

    let playerhand = [];
    let dealerhand = [];
    let discardHand = [];
    let playerScore = 0;
    let dealerScore = 0;

    const suits = ["hearts", "spades", "diamonds", "clubs"];

    const deck = [];
    let cardId = 0;
    const fillDeck = () => {
        suits.forEach((suit, i) => {
            for (let index = 2; index <= 14; index++) {
                let rank
                let value = 10;
                let HiLo
                
                switch (index) {
                    case 11:
                        rank = "J"
                        break;
                    case 12:
                        rank = "Q"
                        break;
                    case 13:
                        rank = "K"
                        break;
                    case 14:
                        rank = "A"
                        value = 11;
                        break;
                    default:
                        rank = index;
                        value = rank;
                        break;
                }
                deck.push(new Card(cardId++, suit, rank, value)); 
            }
        });
    }

    const fillShoe = () => {
        runFunctionXTimes(fillDeck,0 ,6);
        // fillDeck();
        // fillDeck();
        // fillDeck();
        // fillDeck();
        // fillDeck();
        // fillDeck();
    }

    const getRandomCard = () => {
        if(deck.length == 0){
            console.log("ran out of cards");
        }
        return deck[Math.floor(Math.random()*deck.length)]
    }

    const playerHit = (flipped) => {
        if(!gameRunning){
            console.log("game not Running");
            return
        }
        const card = getRandomCard()
        if (!card){return}
        playerhand.push(card)
        const cardIndex = deck.findIndex(deckCard => deckCard.cardId === card.cardId);
        if (cardIndex !== -1){deck.splice(cardIndex, 1);}        
        playerScore += card.value;
        playerHandCont.addCard(card, flipped);
        if (playerScore > 21) {
            console.log("Player busts! Dealer wins.", playerScore, "vs", dealerScore);
            endGame();
        }        
        countCards();
        updateScore();

    }

    const playerStay = () => {
        if(!gameRunning){
            console.log("game not Running");
            return
        }
        while(dealerScore < 17){dealerPlay()}
        check();
        countCards();
    }

    const dealerPlay = (flipped) => {
        const card = getRandomCard()
        if (!card){return}
        dealerhand.push(card)
        const cardIndex = deck.findIndex(deckCard => deckCard.cardId === card.cardId);
        if (cardIndex !== -1){deck.splice(cardIndex, 1);}
        dealerScore += card.value;
        dealerHandCont.addCard(card, flipped);
        countCards();
        updateScore();

    }

    const countCards = () => {
        let count = 0;
        playerhand.forEach(e => {
            count += e.HiLo;
        })
        dealerhand.forEach(e => {
            count += e.HiLo;
        })
        discardHand.forEach(e => {
            count += e.HiLo
        })
        cardCountingCount.textContent = count;
    }

    const check = () => {
        console.log("Player Score:", playerScore);
        console.log("Dealer Score:", dealerScore);
        if (playerScore > 21){
            console.log("Dealer Wins!");
            endGame();
        }
        if (dealerScore > 21){
            console.log("Player Wins!");
            playerWon();
            endGame();
        }
        if (gameRunning && dealerScore >= 17) {
            if (playerScore > dealerScore) {
                console.log("Player Wins!");
                playerWon();
            } else if (playerScore < dealerScore) {
                console.log("Dealer Wins!");
            } else {
                console.log("It's a Tie!");
                playerTied();
            }
            endGame();
        }
        updateScore();
    }

    const updateScore = () => {
        playerScoreElement.textContent = `Player: ${playerScore}`;
        dealerScoreElement.textContent = `Dealer: ${dealerScore}`;
    }
    
    const discardPlayerHand = () => {
        removeAll(playerHandCont.element);
        playerHandCont.clearCards();
        playerhand.forEach(card => {
            discardHand.push(card)
            discardCont.addCard(card, true)
        });
        console.log(discardHand);

        playerhand = [];
    }

    const discardDealerHand = () => {
        removeAll(dealerHandCont.element);
        dealerHandCont.clearCards();
        dealerhand.forEach(card => {
            discardHand.push(card)
            discardCont.addCard(card, true)
        });
        console.log(discardHand);
        
        dealerhand = [];
    }

    const playerWon = () => {
        playerBalance += 2 * betAmount;
        console.log(playerBalance);
        
        playerBalanceElement.textContent = playerBalance;
    }

    const playerTied = () => {
        playerBalance += 1 * betAmount;
        console.log(playerBalance);

        playerBalanceElement.textContent = playerBalance;
    }

    const startGame = () => {
        if(!gameRunning){
            if(!betInput.value == ""){
                betAmount = betInput.value;
                playerBalance -= betAmount;
                
                playerBalanceElement.textContent = playerBalance;
                console.log(playerBalanceElement.textContent);
                
                console.log("gameStarted");
                
                gameRunning = true;
                playerHit(false);
                playerHit(false);
                dealerPlay(false);
                dealerPlay(true);
            } else {
                console.log("Enter Valid Bet Value");
                
            }
            
        } else{console.log("game already started");}   
    }

    const endGame = () => {
        gameRunning = false;
        playerScore = 0;
        dealerScore = 0;
        discardPlayerHand();
        discardDealerHand();
    }
    
    fillShoe();
    console.log(deck);

    playerhitButton.addEventListener('click', () => playerHit(false));
    playerstayButton.addEventListener('click', () => playerStay());
    betButton.addEventListener('click', () => startGame());

</script>
</body>
</html>